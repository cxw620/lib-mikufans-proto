// This file is @generated by prost-build.
///
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BapiLiveRtcLegacyProto {}
/// Nested message and enum types in `BAPILiveRTCLegacyProto`.
pub mod bapi_live_rtc_legacy_proto {
    ///
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MediaTypeField {
        ///
        #[prost(int32, repeated, tag = "1")]
        pub media_type: ::prost::alloc::vec::Vec<i32>,
    }
    ///
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RtcSubscribe {
        ///
        #[prost(map = "int32, message", tag = "1")]
        pub subscribe: ::std::collections::HashMap<i32, MediaTypeField>,
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MediaType {
        ///
        Audio = 0,
        ///
        Video = 1,
        ///
        Data = 2,
        ///
        SmallVideo = 3,
        ///
        Other = 15,
    }
    impl MediaType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MediaType::Audio => "AUDIO",
                MediaType::Video => "VIDEO",
                MediaType::Data => "DATA",
                MediaType::SmallVideo => "SMALL_VIDEO",
                MediaType::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUDIO" => Some(Self::Audio),
                "VIDEO" => Some(Self::Video),
                "DATA" => Some(Self::Data),
                "SMALL_VIDEO" => Some(Self::SmallVideo),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
///
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BapiLiveRtcStreamProto {}
/// Nested message and enum types in `BAPILiveRTCStreamProto`.
pub mod bapi_live_rtc_stream_proto {
    ///
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AudioMetaData {
        ///
        #[prost(int64, tag = "1")]
        pub channels: i64,
        ///
        #[prost(int64, tag = "2")]
        pub sample_rate: i64,
        ///
        #[prost(int64, tag = "3")]
        pub payload: i64,
        ///
        #[prost(int32, tag = "4")]
        pub ssrc: i32,
    }
    ///
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct StreamMeta {
        ///
        #[prost(enumeration = "Codec", tag = "1")]
        pub codec: i32,
        ///
        #[prost(oneof = "stream_meta::Metadata", tags = "2, 3")]
        pub metadata: ::core::option::Option<stream_meta::Metadata>,
    }
    /// Nested message and enum types in `StreamMeta`.
    pub mod stream_meta {
        ///
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Metadata {
            ///
            #[prost(message, tag = "2")]
            Audio(super::AudioMetaData),
            ///
            #[prost(message, tag = "3")]
            Video(super::VideoMetaData),
        }
    }
    ///
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct VideoMetaData {
        ///
        #[prost(int64, tag = "1")]
        pub payload: i64,
        ///
        #[prost(int32, tag = "2")]
        pub ssrc: i32,
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Codec {
        ///
        Opus = 0,
        ///
        H264 = 1,
    }
    impl Codec {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Codec::Opus => "Opus",
                Codec::H264 => "H264",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Opus" => Some(Self::Opus),
                "H264" => Some(Self::H264),
                _ => None,
            }
        }
    }
}
///
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BapiLiveRtcTokenProto {}
/// Nested message and enum types in `BAPILiveRTCTokenProto`.
pub mod bapi_live_rtc_token_proto {
    ///
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AccessToken {
        ///
        #[prost(int64, tag = "1")]
        pub channel_id: i64,
        ///
        #[prost(int64, tag = "2")]
        pub uid: i64,
        ///
        #[prost(string, tag = "3")]
        pub token: ::prost::alloc::string::String,
        ///
        #[prost(string, repeated, tag = "4")]
        pub addr: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        ///
        #[prost(string, tag = "5")]
        pub fingerprint: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "6")]
        pub password: ::prost::alloc::string::String,
        ///
        #[prost(string, repeated, tag = "7")]
        pub http_dns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        ///
        #[prost(int32, tag = "8")]
        pub version: i32,
        ///
        #[prost(string, tag = "9")]
        pub business_name: ::prost::alloc::string::String,
    }
    ///
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Token {
        ///
        #[prost(int64, tag = "1")]
        pub channel_id: i64,
        ///
        #[prost(int64, tag = "2")]
        pub uid: i64,
        ///
        #[prost(int64, tag = "3")]
        pub timestamp: i64,
        ///
        #[prost(enumeration = "super::bapi_live_rtc_user_proto::UserRole", tag = "4")]
        pub role: i32,
    }
}
///
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BapiLiveRtcUserProto {}
/// Nested message and enum types in `BAPILiveRTCUserProto`.
pub mod bapi_live_rtc_user_proto {
    ///
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Stream {
        ///
        #[prost(bool, tag = "1")]
        pub has_video: bool,
        ///
        #[prost(bool, tag = "2")]
        pub has_audio: bool,
        ///
        #[prost(bool, tag = "3")]
        pub audio_muted: bool,
        ///
        #[prost(bool, tag = "4")]
        pub video_muted: bool,
        ///
        #[prost(int32, tag = "5")]
        pub video_count: i32,
        ///
        #[prost(int32, tag = "6")]
        pub temporal_count: i32,
    }
    ///
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct User {
        ///
        #[prost(int64, tag = "1")]
        pub uid: i64,
        ///
        #[prost(enumeration = "UserRole", tag = "2")]
        pub role: i32,
        ///
        #[prost(message, optional, tag = "3")]
        pub pub_stream: ::core::option::Option<Stream>,
        ///
        #[prost(string, tag = "4")]
        pub platform: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "5")]
        pub sdk_version: ::prost::alloc::string::String,
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserLeaveReason {
        ///
        Normal = 0,
        ///
        Kicked = 1,
        ///
        Timeout = 2,
        ///
        Killed = 3,
        ///
        Reconnect = 4,
    }
    impl UserLeaveReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserLeaveReason::Normal => "NORMAL",
                UserLeaveReason::Kicked => "KICKED",
                UserLeaveReason::Timeout => "TIMEOUT",
                UserLeaveReason::Killed => "KILLED",
                UserLeaveReason::Reconnect => "RECONNECT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NORMAL" => Some(Self::Normal),
                "KICKED" => Some(Self::Kicked),
                "TIMEOUT" => Some(Self::Timeout),
                "KILLED" => Some(Self::Killed),
                "RECONNECT" => Some(Self::Reconnect),
                _ => None,
            }
        }
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserRole {
        ///
        Normal = 0,
        ///
        Audience = 1,
        ///
        Monitor = 2,
        ///
        Relay = 3,
        ///
        App = 4,
        ///
        Mix = 5,
        ///
        Unknown = 99,
    }
    impl UserRole {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserRole::Normal => "Normal",
                UserRole::Audience => "Audience",
                UserRole::Monitor => "Monitor",
                UserRole::Relay => "Relay",
                UserRole::App => "App",
                UserRole::Mix => "Mix",
                UserRole::Unknown => "Unknown",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Normal" => Some(Self::Normal),
                "Audience" => Some(Self::Audience),
                "Monitor" => Some(Self::Monitor),
                "Relay" => Some(Self::Relay),
                "App" => Some(Self::App),
                "Mix" => Some(Self::Mix),
                "Unknown" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
